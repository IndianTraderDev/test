<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free ScreenRecorder App - Screen & Camera Recorder</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Client-side WebM to MP4 Conversion Library (for browser compatibility) -->
    <!-- NOTE: This is required to satisfy the MP4 download request using client-side conversion. -->
    <script src="https://cdn.jsdelivr.net/npm/ts-ebml@2.0.2/ts-ebml.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webm-to-mp4@1.0.0/dist/webm-to-mp4.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Custom scrollbar for the controls panel */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #a0aec0;
            border-radius: 3px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #edf2f7;
        }
        /* Style for the video player container */
        #previewContainer {
            min-height: 250px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="max-w-4xl mx-auto bg-white shadow-xl rounded-xl p-6 md:p-10">

        <!-- Header -->
        <header class="mb-8">
            <h1 class="text-3xl font-extrabold text-gray-800 flex items-center">
                <svg class="w-8 h-8 text-indigo-600 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                Screen Recorder
            </h1>
            <p class="text-gray-500 mt-2">Capture your screen, camera, and microphone in one click. Now downloads in MP4 format.</p>
        </header>

        <!-- Configuration and Controls -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">

            <!-- Configuration Panel -->
            <div id="configPanel" class="lg:col-span-1 bg-gray-50 p-5 rounded-lg border border-gray-200 custom-scroll overflow-y-auto max-h-[300px]">
                <h2 class="text-lg font-semibold text-gray-700 mb-4">Capture Sources</h2>
                <div class="space-y-4">
                    <!-- Screen Toggle -->
                    <label class="flex items-center justify-between p-3 bg-white rounded-lg shadow-sm cursor-pointer hover:bg-indigo-50 transition duration-150">
                        <span class="font-medium text-gray-700">Screen Sharing</span>
                        <input type="checkbox" id="screenToggle" checked class="h-5 w-5 text-indigo-600 rounded focus:ring-indigo-500 focus:ring-offset-2">
                    </label>

                    <!-- Camera Toggle -->
                    <label class="flex items-center justify-between p-3 bg-white rounded-lg shadow-sm cursor-pointer hover:bg-indigo-50 transition duration-150">
                        <span class="font-medium text-gray-700">Webcam Feed</span>
                        <input type="checkbox" id="cameraToggle" class="h-5 w-5 text-indigo-600 rounded focus:ring-indigo-500 focus:ring-offset-2">
                    </label>

                    <!-- Microphone Toggle -->
                    <label class="flex items-center justify-between p-3 bg-white rounded-lg shadow-sm cursor-pointer hover:bg-indigo-50 transition duration-150">
                        <span class="font-medium text-gray-700">Microphone Audio</span>
                        <input type="checkbox" id="micToggle" class="h-5 w-5 text-indigo-600 rounded focus:ring-indigo-500 focus:ring-offset-2">
                    </label>
                </div>

                <!-- Status Message -->
                <div id="statusMessage" class="mt-4 p-2 text-sm text-center rounded-lg hidden"></div>
            </div>

            <!-- Controls and Timer -->
            <div class="lg:col-span-2 flex flex-col justify-center items-center p-5 bg-indigo-50 rounded-lg border-2 border-indigo-200">
                <div id="timerDisplay" class="text-5xl font-mono font-bold text-gray-800 mb-6">00:00:00</div>

                <div class="flex space-x-4">
                    <!-- Start/Stop Button -->
                    <button id="recordButton" class="px-8 py-3 text-white font-bold rounded-full shadow-lg transition duration-300 transform active:scale-95 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 disabled:shadow-none" onclick="toggleRecording()">
                        Start Recording
                    </button>

                    <!-- Pause/Resume Button (Hidden initially) -->
                    <button id="pauseButton" class="px-6 py-3 text-white font-bold rounded-full shadow-lg transition duration-300 transform active:scale-95 bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-400 disabled:shadow-none hidden" onclick="togglePause()">
                        Pause
                    </button>
                </div>

                <!-- Error Message -->
                <p id="errorMessage" class="text-red-600 mt-4 text-sm text-center hidden"></p>
                <!-- Conversion Status -->
                <p id="conversionStatus" class="text-indigo-700 mt-4 text-sm text-center hidden font-semibold"></p>
            </div>
        </div>

        <!-- Video Preview and Download Section -->
        <div class="mt-8 p-6 bg-gray-100 rounded-xl shadow-inner">
            <h2 class="text-xl font-bold text-gray-700 mb-4">Output Preview</h2>
            
            <div id="previewContainer" class="relative bg-gray-300 rounded-lg overflow-hidden w-full aspect-video">
                <video id="livePreview" autoplay muted class="absolute inset-0 w-full h-full object-contain bg-black"></video>
                <div id="initialMessage" class="absolute inset-0 flex items-center justify-center text-gray-600 text-lg font-medium p-4 bg-white/80 backdrop-blur-sm">
                    Select your sources and click "Start Recording"
                </div>
                <!-- Camera Feed (as Picture-in-Picture style overlay) -->
                <video id="cameraPreview" autoplay muted class="absolute top-3 right-3 w-40 h-auto rounded-lg shadow-xl border-2 border-white object-cover hidden"></video>
            </div>
            
            <!-- Download Button (Hidden until recording is complete) -->
            <div id="downloadArea" class="mt-4 flex justify-center hidden">
                <button id="downloadButton" class="px-6 py-3 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition duration-150 transform active:scale-95" onclick="downloadRecording()">
                    <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    Download MP4 Video
                </button>
            </div>
        </div>

    </div>

    <script>
        // State variables
        let mediaRecorder;
        let recordedChunks = [];
        let screenStream = null;
        let cameraStream = null;
        let micStream = null;
        let recordingState = 'idle'; // 'idle', 'recording', 'paused'
        let timerInterval = null;
        let startTime = 0;
        let finalMp4Blob = null; // Stores the converted MP4 Blob

        // DOM elements
        const recordButton = document.getElementById('recordButton');
        const pauseButton = document.getElementById('pauseButton');
        const downloadButton = document.getElementById('downloadButton');
        const livePreview = document.getElementById('livePreview');
        const cameraPreview = document.getElementById('cameraPreview');
        const timerDisplay = document.getElementById('timerDisplay');
        const initialMessage = document.getElementById('initialMessage');
        const downloadArea = document.getElementById('downloadArea');
        const errorMessage = document.getElementById('errorMessage');
        const conversionStatus = document.getElementById('conversionStatus');

        // Configuration Toggles
        const screenToggle = document.getElementById('screenToggle');
        const cameraToggle = document.getElementById('cameraToggle');
        const micToggle = document.getElementById('micToggle');

        // --- Utility Functions ---

        /**
         * Safely stops all tracks in a MediaStream.
         * @param {MediaStream | null} stream 
         */
        function stopStream(stream) {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        }

        /**
         * Clears all stream and preview sources.
         */
        function clearPreview() {
            livePreview.srcObject = null;
            cameraPreview.srcObject = null;
            livePreview.src = ''; 
            livePreview.controls = false;
            finalMp4Blob = null;
        }

        /**
         * Updates the UI based on the current recording state, carefully preserving
         * the finished video preview if it exists.
         */
        function updateUI() {
            errorMessage.classList.add('hidden');
            
            const isRecording = recordingState !== 'idle';
            
            // Determine if a finished video is currently loaded for playback 
            const hasFinishedVideo = recordingState === 'idle' && finalMp4Blob !== null;
            
            // --- UI Visibility ---

            // 1. Initial Message Visibility: Only show if truly idle (no active recording, no finished video preview)
            if (recordingState === 'idle' && !hasFinishedVideo) {
                initialMessage.classList.remove('hidden');
            } else {
                initialMessage.classList.add('hidden');
            }
            
            // 2. Download Area Visibility: Only show if a finished video is loaded.
            if (hasFinishedVideo) {
                downloadArea.classList.remove('hidden');
            } else {
                downloadArea.classList.add('hidden');
            }
            
            // 3. Hide camera preview when idle
            if (recordingState === 'idle') {
                cameraPreview.classList.add('hidden');
            }


            // --- Button and Toggle State ---

            recordButton.disabled = false;
            if (recordingState === 'idle') {
                recordButton.textContent = 'Start Recording';
                recordButton.classList.replace('bg-green-600', 'bg-red-600');
                recordButton.classList.replace('hover:bg-green-700', 'hover:bg-red-700');
                pauseButton.classList.add('hidden');
            } else if (recordingState === 'recording') {
                recordButton.textContent = 'Stop Recording';
                recordButton.classList.replace('bg-red-600', 'bg-green-600');
                recordButton.classList.replace('hover:bg-red-700', 'hover:bg-green-700');
                pauseButton.textContent = 'Pause';
                pauseButton.classList.remove('hidden');
            } else if (recordingState === 'paused') {
                recordButton.textContent = 'Stop Recording';
                pauseButton.textContent = 'Resume';
            }

            // Disable toggles when recording is active
            screenToggle.disabled = isRecording;
            cameraToggle.disabled = isRecording;
            micToggle.disabled = isRecording;
        }

        /**
         * Formats milliseconds into HH:MM:SS string.
         * @param {number} ms - time in milliseconds
         * @returns {string} Formatted time string
         */
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const pad = (num) => String(num).padStart(2, '0');
            return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }

        /**
         * Starts the timer.
         */
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                timerDisplay.textContent = formatTime(elapsed);
            }, 1000);
        }

        /**
         * Stops and resets the timer.
         */
        function stopTimer() {
            clearInterval(timerInterval);
            timerDisplay.textContent = '00:00:00';
        }

        // --- Core Recording Logic ---

        /**
         * Acquires all selected media streams (screen, camera, mic).
         */
        async function acquireStreams() {
            const isScreenSelected = screenToggle.checked;
            const isCameraSelected = cameraToggle.checked;
            const isMicSelected = micToggle.checked;

            if (!isScreenSelected && !isCameraSelected) {
                throw new Error("You must select at least Screen or Webcam to record video.");
            }

            try {
                // 1. Acquire Screen Stream
                if (isScreenSelected) {
                    screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true
                    });
                    livePreview.srcObject = screenStream;
                    livePreview.load();
                } else {
                    livePreview.srcObject = null;
                }

                // 2. Acquire Camera Stream
                if (isCameraSelected) {
                    cameraStream = await navigator.mediaDevices.getUserMedia({
                        video: true
                    });

                    // If screen is also active, camera is the picture-in-picture overlay
                    if (isScreenSelected) {
                        cameraPreview.srcObject = cameraStream;
                        cameraPreview.classList.remove('hidden');
                        cameraPreview.load();
                    } else {
                        // If only camera is selected, it is the main preview
                        livePreview.srcObject = cameraStream;
                        livePreview.load();
                        cameraPreview.classList.add('hidden');
                    }
                } else {
                    cameraPreview.classList.add('hidden');
                }

                // 3. Acquire Microphone Stream and merge audio
                if (isMicSelected) {
                    micStream = await navigator.mediaDevices.getUserMedia({
                        audio: true
                    });
                }
                
                // 4. Combine all streams into one stream for recording
                const combinedStream = new MediaStream();

                // Add video track (from screen or camera)
                const videoTrack = (screenStream || cameraStream).getVideoTracks()[0];
                if (videoTrack) {
                    combinedStream.addTrack(videoTrack);
                }

                // Add audio track (prioritize screen/camera audio if available, otherwise use mic)
                let audioTrack = null;

                // 4a. Get system audio from screen sharing (if selected)
                if (screenStream) {
                    audioTrack = screenStream.getAudioTracks()[0];
                }

                // 4b. If no system audio, use microphone audio (if selected)
                if (!audioTrack && micStream) {
                    audioTrack = micStream.getAudioTracks()[0];
                }

                // Add the resulting audio track
                if (audioTrack) {
                    combinedStream.addTrack(audioTrack);
                }
                
                // When the screen share stops externally
                if (screenStream) {
                    screenStream.getVideoTracks()[0].onended = () => {
                        if (recordingState === 'recording') {
                            stopRecording();
                            errorMessage.textContent = "Screen sharing stopped by the user.";
                            errorMessage.classList.remove('hidden');
                        }
                    };
                }

                return combinedStream;

            } catch (error) {
                console.error("Error acquiring media streams:", error);
                
                let userMessage = "Could not access media devices. Please check permissions and device availability.";
                
                if (error.name === 'NotAllowedError') {
                    if (isScreenSelected) {
                        userMessage = "Screen sharing access was denied by your browser or environment. Try unchecking 'Screen Sharing' and recording only your 'Webcam Feed'.";
                    } else {
                        userMessage = "Webcam or Microphone access was denied. Please allow camera/mic access.";
                    }
                } else if (error.name === 'NotFoundError') {
                    userMessage = "No camera or microphone devices found.";
                }

                throw new Error(userMessage + (error.name ? ` (Error Type: ${error.name})` : ''));
            }
        }

        /**
         * Starts the MediaRecorder.
         * @param {MediaStream} stream - The combined stream to record.
         */
        function startRecording(stream) {
            recordedChunks = [];
            // Use vp9 codec for better quality if available
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9,opus' });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = async () => {
                // Perform cleanup
                stopStream(screenStream);
                stopStream(cameraStream);
                stopStream(micStream);
                stopTimer();
                clearPreview();
                
                // 1. Create WebM blob from chunks
                const webmBlob = new Blob(recordedChunks, { type: 'video/webm' });

                // 2. Start conversion status update
                conversionStatus.textContent = "Converting to MP4... Please wait.";
                conversionStatus.classList.remove('hidden');
                recordButton.disabled = true;

                try {
                    // 3. Convert WebM Blob to MP4 Blob using the client-side library
                    const converter = new WebMToMp4();
                    const mp4Blob = await converter.convert(webmBlob, {
                        audio: true,
                        video: true,
                        // Ensure the blob is not too large for the conversion process
                        maxFileSize: 1024 * 1024 * 1024 // 1GB
                    });

                    // 4. Store the final MP4 blob and display preview
                    finalMp4Blob = mp4Blob;
                    const videoUrl = URL.createObjectURL(finalMp4Blob);
                    
                    livePreview.src = videoUrl;
                    livePreview.muted = false; 
                    livePreview.controls = true; 
                    livePreview.classList.remove('hidden');

                    // 5. Update UI for finished state
                    conversionStatus.classList.add('hidden');
                    recordingState = 'idle';
                    updateUI();

                } catch (error) {
                    console.error("MP4 Conversion Failed:", error);
                    conversionStatus.classList.add('hidden');
                    errorMessage.textContent = "MP4 conversion failed. Downloading original WebM instead. Error: " + error.message;
                    errorMessage.classList.remove('hidden');
                    
                    // Fallback to WebM download
                    finalMp4Blob = webmBlob;
                    downloadButton.textContent = 'Download WebM Video (Fallback)';
                    
                    const videoUrl = URL.createObjectURL(finalMp4Blob);
                    livePreview.src = videoUrl;
                    livePreview.muted = false; 
                    livePreview.controls = true; 
                    livePreview.classList.remove('hidden');
                    
                    recordingState = 'idle';
                    updateUI();
                }
            };
            
            mediaRecorder.onerror = (e) => {
                console.error('MediaRecorder error:', e);
                errorMessage.textContent = `Recording failed: ${e.error.name}. Try selecting different sources.`;
                errorMessage.classList.remove('hidden');
                stopRecording(false); 
            };


            mediaRecorder.start(1000); 
            recordingState = 'recording';
            livePreview.muted = true; 
            livePreview.controls = false; 
            updateUI();
            startTimer();
        }

        /**
         * Stops the recording process.
         * @param {boolean} triggerStop - Whether to trigger mediaRecorder.stop() (default: true).
         */
        function stopRecording(triggerStop = true) {
            if (mediaRecorder && mediaRecorder.state !== 'inactive' && triggerStop) {
                mediaRecorder.stop();
            } else {
                // Manual cleanup if stop() wasn't called (e.g., error case)
                stopStream(screenStream);
                stopStream(cameraStream);
                stopStream(micStream);
                stopTimer();
                clearPreview();
                
                recordingState = 'idle';
                updateUI();
            }
        }
        
        // --- Button Handlers ---

        /**
         * Main handler to start or stop the recording.
         */
        async function toggleRecording() {
            if (recordingState === 'idle') {
                recordButton.disabled = true;
                recordButton.textContent = 'Preparing...';
                
                if (!screenToggle.checked && !cameraToggle.checked) {
                    errorMessage.textContent = "Please select at least Screen or Webcam to begin recording.";
                    errorMessage.classList.remove('hidden');
                    recordButton.disabled = false;
                    recordButton.textContent = 'Start Recording';
                    return;
                }

                // Clear any previous artifacts
                clearPreview();
                conversionStatus.classList.add('hidden');
                downloadButton.textContent = 'Download MP4 Video';

                try {
                    const stream = await acquireStreams();
                    startRecording(stream);
                } catch (error) {
                    // Cleanup and show error message
                    stopStream(screenStream);
                    stopStream(cameraStream);
                    stopStream(micStream);
                    clearPreview();
                    
                    errorMessage.textContent = error.message;
                    errorMessage.classList.remove('hidden');
                    
                    recordingState = 'idle';
                    updateUI();
                }
            } else if (recordingState === 'recording' || recordingState === 'paused') {
                stopRecording();
            }
        }

        /**
         * Handler to pause or resume the recording.
         */
        function togglePause() {
            if (mediaRecorder) {
                if (recordingState === 'recording') {
                    mediaRecorder.pause();
                    recordingState = 'paused';
                    pauseButton.textContent = 'Resume';
                    clearInterval(timerInterval);
                } else if (recordingState === 'paused') {
                    mediaRecorder.resume();
                    recordingState = 'recording';
                    pauseButton.textContent = 'Pause';
                    startTimer(); 
                }
                updateUI();
            }
        }
        
        /**
         * Handles the final download of the MP4 (or fallback WebM) file.
         */
        function downloadRecording() {
            if (!finalMp4Blob) {
                errorMessage.textContent = "Error: Video data is not ready for download.";
                errorMessage.classList.remove('hidden');
                return;
            }

            const isMp4 = finalMp4Blob.type === 'video/mp4';
            const extension = isMp4 ? 'mp4' : 'webm';
            const mimeType = isMp4 ? 'video/mp4' : 'video/webm';
            
            const url = URL.createObjectURL(finalMp4Blob);
            const a = document.createElement('a');
            
            a.href = url;
            a.download = `recording-${new Date().toISOString().slice(0, 10)}.${extension}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize UI on load
        window.onload = updateUI;
    </script>
</body>
</html>
